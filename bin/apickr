#!/usr/bin/env perl

=head1 NAME

apickr - Synchronize aperture library and flickr account.

=head1 SYNOPSIS

apickr [OPTIONS] COMMAND PATH

Synchronize aperture library given by PATH with flickr.

=head1 COMMANDS

  albums              list albums
  images              list images
  sync                sync with flickr
  match               match aperture images with flickr photos
  flickr-fix          fix flickr dates from exif
  flickr-photosets    list flickr photosets
  flickr-photos       list flickr photos
  flickr-backup PATH  backup metadata for selected photos to PATH
  flickr-restore PATH restore metadata for selected photos from PATH

=head1 OPTIONS

 --help|-h         brief help message
 --num=NUM         only process NUM items
 --album|-a=REGEX  only process albums or photosets which match REGEX
 --title|-t=REGEX  only process images or photos which match REGEX
 --word|-w         only match --album or --title at word boundaries
 --id              only process photo/image or photoset/album with this id
 --filter|-f=REGEX only display/count results where any key or any value match REGEX
 --not|--invert    only display/count results where no key or value match --filter
 --count|-c        count number of results
 --classify=FIELD  count number of results per FIELD value
 --verbose|-v      output verbose information
 --select|-s       regex to select *additional* keys to display
                   or the *only* keys to write for restore/sync.
 --dry-run|-n      only output changes to flickr data
 --force|-f        overwrite already existing backups with flickr-backup
 --exif            add exif data to images and photos
 --contexts        add contexts (photosets...) to flickr photos
 --info            add additional info to flickr photos
 --fix-date-upload also set the upload date to the date taken in flickr-fix
 --upload          upload missing photos to flickr during sync

=head1 AUTHOR

 Nathan Gass <gass@search.ch>

=cut

$0 = 'apickr';

use Modern::Perl;
use autodie;
use common::sense;

use Coro;
use Coro::LWP;
use Getopt::Long qw/:config/;
use Pod::Usage;
use YAML::Syck qw/LoadFile DumpFile Load Dump/;
$YAML::Syck::ImplicitUnicode = 1;
use DBI;
use Flickr::API2;
use File::Spec::Functions qw/splitpath catdir/;
use Browser::Open qw/open_browser/;
use List::AllUtils qw/first max min any all sum/;
use Encode qw/decode_utf8 encode decode/;
use Encode::Locale;
use DateTime;
use DateTime::Format::Strptime;
use DateTime::Format::Epoch;
use DateTime::Format::Flexible;
use Carp qw/confess cluck/;
use String::ProgressBar;
use File::Slurp;
use Image::ExifTool qw/ImageInfo GetAllTags/;
use Image::ExifTool::TagLookup qw/FindTagInfo/;
use LWP::Simple qw/get/;
use HTTP::Request::Common;
use XML::LibXML::Simple qw/XMLin/;

my @podargs = (-verbose => 99, -sections => [qw/NAME SYNOPSIS COMMANDS OPTIONS/]);
my $config = {};
{
	local $@;
	eval {
		$config = LoadFile(catdir($ENV{HOME}, '.apickrrc'));
	};
}
my $opts = {};
GetOptions(
	$opts,
	'help|h', 'num=i', 'album|a=s', 'title|t=s', 'word|t', 'id=s', 'verbose|v+',
	'select|s=s', 'dry-run|n', 'force|f', 'exif', 'contexts', 'info', 'fix-date-upload', 'count|c',
	'filter|f=s', 'classify=s', 'not|invert', 'upload',
) or pod2usage(-exitval => 2, @podargs);
pod2usage(@podargs) if $opts->{help};
$config = {%$config, %$opts};

if ($opts->{id}) {
	my $id = delete $opts->{id};
	$opts->{ $id =~ /^\d+$/ ? 'ickr_id' : 'ap_id' } = $id;
}

my $command = shift() || "albums";
my $path;
if ($command !~ /^flickr-/) {
	$path = shift() || catdir($ENV{HOME}, 'Pictures', 'Portugal 2012.aplibrary');
}

my @global_wait_coros;

given ($command) {

	when ("albums") {
		display(aperture_select_albums());
	}

	when ("images") {
		my $gen = aperture_select_images();
		$gen = aperture_add_exif($gen)
			if $opts->{exif};
		display($gen);
	}

	when ("match") {
		my $ap_gen   = aperture_select_images();
		my $ickr_gen = parallelize(flickr_photos_list());
		display(flickr_add_photo_info(apickr_match($ap_gen, $ickr_gen)));
	}

	when ("sync") {
		apickr_sync();
	}

	when ("flickr-backup") {
		flickr_backup(@ARGV);
	}

	when ("flickr-restore") {
		flickr_restore(@ARGV);
	}

	when ("flickr-fix") {
		flickr_fix();
	}

	when ("flickr-photosets") {
		display(flickr_photosets_list(total => $opts->{num}));
	}

	when ("flickr-photos") {
		my $gen = flickr_photos_list();
		if ($opts->{exif} || $opts->{contexts} || $opts->{info}) {
			$gen = flickr_add_contexts($gen)   if $opts->{contexts};
			$gen = flickr_add_photo_info($gen) if $opts->{info};
			$gen = flickr_add_exif($gen)       if $opts->{exif};
			$gen = parallelize($gen);
		}
		display($gen);
	}

	default {die "Unknown command $_"}
};

$_->join() foreach @global_wait_coros;

exit;

sub flickr_auth {
	my $api = shift;
	my $auth = {};
	my $authpath = catdir($ENV{HOME}, '.apickr.auth');
	if (-e $authpath) {
		$auth = LoadFile($authpath);
	}
	if (!$auth->{token}) {
		my $frob = flickr_api('auth.getFrob', api_key => $api->raw->{api_key});
		my $url = $api->raw->request_auth_url('write', $frob);
		open_browser($url);
		say "Please authorize apickr to read and write to your flickr account.";
		say "Press any key to continue.";
		local $| = 0;
		getc;
		$auth = flickr_api('auth.getToken', frob => $frob);
		DumpFile($authpath, $auth);
	}
	return $auth;
}

sub flickr_api {
	state $api  = Flickr::API2->new({key => '04c25240b84f6f5d32e8e43fd4deb249', secret => 'abef06bf4946a4a2'});
	state $auth = flickr_auth($api);
	my $method = shift;
	my $params = {@_};
	$params->{auth_token} = $auth->{token}
		if $auth;
	my $req;
	if (($opts->{verbose} || $opts->{'dry-run'}) && $method =~ /\.(set|remove|delete|add|edit|upload)/) {
		print "\n", 'flickr.' . $method, "\n", Dump($params), "\n";
		return undef if $opts->{'dry-run'};
	} elsif  ($opts->{verbose} > 1) {
		print "\n", 'flickr.' . $method, "\n", Dump($params), "\n";
	}

	if ($method eq 'photos.upload') {
		my $raw = $api->raw();
		my $photo = delete $params->{photo};
		$params = {
			api_key        => $raw->{api_key},
			%$params,
		};
		$params->{api_sig} = $raw->sign_args($raw->{api_secret}, $params);
		$params->{photo}   = [$photo];
		my $req = POST 'http://api.flickr.com/services/upload/', 'Content_Type' => 'form-data', 'Content' => $params;
		my $response = $raw->do_request($req);
		die("API call failed with HTTP status: " . $response->code . "\n")
			unless $response->code == 200;
		my $content = $response->decoded_content;
		$content = $response->content() unless defined $content;
		my $result = XMLin($content);

		return $result if ($result->{stat} eq 'ok');

		die sprintf("API call failed: \%s (\%s)\n", $result->{err}{msg}, $result->{err}{code});

	} else {
		while(1) {
			eval {
				$req = $api->execute_method('flickr.' . $method, {%$params});
			};
			if ($@ && (!$params->{page} || $params->{page} == 1)) {
				if ($@ =~ /HTTP status: 504/) {
					cluck $@;
				} else {
					confess $@;
				}
			} else {
				last;
			}
		};
		if ($req && $req->{stat} eq 'ok') {
			delete $req->{stat};
			if (%$req) {
				my ($first) = keys $req;
				return simplify_flickr_response($req->{$first}, $params->{page} ? 0 : 1);
			}
		}
	}
	return undef;
}

sub flickr_photos {
	my ($method, $photo, %args) = @_;
	$args{photo_id} = $photo->{id} if $photo->{id};
	return flickr_api('photos.' . $method, %args);
}

sub flickr_photos_selected {
	state $semaphore = Coro::Semaphore->new(10);
	my ($method, $photo, %args) = @_;
	if ($opts->{select}) {
		foreach my $key (keys %args) {
			delete $args{$key} unless $key =~ /$opts->{select}/;
		}
	}
	if (%args) {
		$semaphore->down();
		my $coro = async {
			my $res = flickr_photos($method, $photo, %args);
			$semaphore->up();
			$res;
		};
		push @global_wait_coros, $coro;
		return $coro;
	}
	return undef;
}

sub flickr_photosets {
	my ($method, $photoset, @args) = @_;
	return flickr_api('photosets.' . $method, photoset_id => $photoset->{id}, @args);
}

sub simplify_flickr_response {
	my ($r, $inarray, $inkey) = @_;
	my $singular = $1 if $inkey && $inkey =~ /^(\w+)s$/;
	given (ref $r) {
		when ('HASH') {
			if (exists $r->{_content} && keys($r) == 1) {
				return decode_utf8($r->{_content});
			} elsif ($singular && keys $r == 1 && defined($r->{$singular})) {
				return simplify_flickr_response($r->{$singular}, $inarray,);
			} else {
				return { map {$_ => simplify_flickr_response($r->{$_}, $inarray, $_)} keys %$r };
			}
		}
		when ('ARRAY') {
			if ($inarray && all {ref($::_) eq 'HASH' and $::_->{id} || $::_->{nsid}} @$r) {
				return { map {($_->{id} || $_->{nsid}) => simplify_flickr_response($_, $inarray)} @$r };
			} else {
				return [map {simplify_flickr_response($_, 1)} @$r];
			}
		}
		default {
			return decode_utf8($r);
		}
	}
}

sub flickr_select {
	my ($method, $args) = @_;
	my ($resp, $page, $key, $i, $nextpage_coro);
	my $num = 1;
	my $total = $args->{total};
	delete $args->{total};
	$args->{per_page} = $total // 200;
	my $semaphore = Coro::Semaphore->new();
	return sub {
		my $guard = $semaphore->guard();
		if (!$nextpage_coro and (!$i || (($i >= @{$resp->{$key}} * (3/4)) && (@{$resp->{$key}} == $args->{per_page}) && !$total))) {
			$nextpage_coro = async {
				$args->{page} = ++$page;
				my $resp = flickr_api($method, %$args);
				return undef unless $resp;
				my $key = first {ref($resp->{$_}) eq 'ARRAY'} keys %$resp;
				return undef unless $key && @{$resp->{$key}};
				return ($resp, $key);
			}
		}
		if (!$i or $i == @{$resp->{$key}}) {
			if (!$nextpage_coro) {
				return undef;
			}
			($resp, $key) = $nextpage_coro->join();
			$nextpage_coro = undef;
			$i = 0;
		}
		my $res = $resp->{$key}[$i++];
		$res->{total} = $total // $resp->{total};
		$res->{num} = $num++;
		return $res;
	}
}

sub aperture_select_images {
	return aperture_select(
		($opts->{select} ? 'RKVersion.uuid AS id,*,' : '')
		. "RKFolder.name AS album,RKVersion.name,imagePath,mainRating,versionNumber,RKVersion.imageDate,"
		. "(SELECT GROUP_CONCAT(name) FROM RKKeyword JOIN RKKeywordForVersion on keywordId = RKKeyword.modelId WHERE versionId = RKVersion.modelId) AS keywords,"
		. "(SELECT stringProperty FROM p.RKUniqueString JOIN p.RKIptcProperty ON p.RKUniqueString.modelId = p.RKIptcProperty.stringId WHERE p.RKIptcProperty.versionId = RKVersion.modelId AND p.RKIptcProperty.propertyKey = 'Caption/Abstract') as caption,"
		. "(SELECT stringProperty FROM p.RKUniqueString JOIN p.RKIptcProperty ON p.RKUniqueString.modelId = p.RKIptcProperty.stringId WHERE p.RKIptcProperty.versionId = RKVersion.modelId AND p.RKIptcProperty.propertyKey = 'ObjectName') as title"
	);
}

sub aperture_select_albums {
	return aperture_select(
		($opts->{select} ? 'RKVersion.uuid AS id,*,' : '')
		. "RKFolder.name AS album,"
		. "COUNT(DISTINCT COALESCE(RKVersion.stackUuid,RKVersion.uuid)) AS stacks,"
		. "COUNT(DISTINCT RKVersion.uuid) AS images",
		"GROUP BY RKVersion.projectUuid",
	);
}

sub aperture_select {
	state $calls;

	if ($calls++) {
		confess "aperture_select called more than once";
	}
	my ($select, $add) = @_;
	$add = "" unless $add;
	my $dbpath = catdir($path, 'Database', 'Library.apdb');
	my $dbh = DBI->connect("dbi:SQLite:dbname=$dbpath","", "", { RaiseError => 1, AutoCommit => 0, ReadOnly => 1});
	END {
		if ($dbh) {
			$dbh->rollback; $dbh->disconnect
		};
	}
	{
		local $dbh->{AutoCommit} = 1;
		$dbh->do('ATTACH DATABASE ? AS p;', undef, catdir($path, 'Database', 'Properties.apdb'))
			or die $dbh->errstr;
	}
	my $sql =
		"FROM RKVersion"
		. " JOIN RKFolder ON RKFolder.uuid = RKVersion.projectUuid"
		. " JOIN RKMaster ON RKVersion.masterUuid = RKMaster.uuid"
		. " WHERE RKVersion.isInTrash = 0 AND RKVersion.versionNumber > 0 AND RKFolder.folderType = 2 "
		. ($opts->{album} ? "AND RKFolder.name REGEXP ? " : '')
		. ($opts->{title} ? "AND RKVersion.name REGEXP ? " : '')
		. ($opts->{ap_id} ? "AND (RKFolder.uuid = ? OR RKVersion.uuid = ?) " : '');
	my $count = ($add =~ /GROUP BY ([\w.]+)/) ? 'DISTINCT ' . $1 : '*';
	my $csth = $dbh->prepare("SELECT COUNT($count) " . $sql);
	my $sth = $dbh->prepare("SELECT $select " . $sql . $add . " ORDER BY RKVersion.imageDate " . ($opts->{num} ? " LIMIT ? " : ''));
	my $param = 1;
	if ($opts->{album}) {
		$sth->bind_param($param, $opts->{album});
		$csth->bind_param($param++, $opts->{album});
	}
	if ($opts->{title}) {
		$sth->bind_param($param, $opts->{title});
		$csth->bind_param($param++, $opts->{title});
	}
	if ($opts->{ap_id}) {
		foreach (0..1) {
			$sth->bind_param($param, $opts->{ap_id});
			$csth->bind_param($param++, $opts->{ap_id});
		}
	}
	if ($opts->{num}) {
		$sth->bind_param($param, $opts->{num});
	}

	$csth->execute();
	my ($total) = @{$csth->fetchrow_arrayref};
	my $num = 1;

	$sth->execute();

	return sub {
		return undef unless $sth;
		my $row = $sth->fetchrow_hashref;
		if (!$row) {
			$sth = undef;
			return undef;
		}
		if ($row->{imagePath}) {
			my ($d,$dir,$name) = splitpath($row->{imagePath});
			my $prev = catdir($path, 'Previews', $dir, $row->{uuid}, $row->{name} . ".jpg");
			$row->{path} = -e $prev ? $prev : catdir($path, 'Masters', $row->{imagePath});
		}
		if ($row->{imageDate}) {
			$row->{imageDate} = datetime_aperture($row->{imageDate});
		}
		$row->{total} = $total;
		$row->{num} = $num++;
		return $row;
	}
}

sub aperture_add_exif {
	my ($gen) = @_;
	return sub {
		my $row = $gen->();
		return undef unless $row;
		$row->{exif} = ImageInfo($row->{path});
		return $row;
	}
}

sub datetime_aperture {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	state $macepoch  = DateTime::Format::Epoch->new(
		epoch => DateTime->new(year => 2001, month => 1, day => 1),
	);
	state $timezone  = DateTime::TimeZone->new('name' => 'local');
	my ($val) = @_;
	my $res = $macepoch->parse_datetime(shift) or die "Could not parse aperture date '$val'\n";
	$res->set_formatter($formatter);
	$res->set_time_zone($timezone);
	return $res;
}

sub datetime_exif {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	state $parser = DateTime::Format::Strptime->new(pattern => '%Y:%m:%d %H:%M:%S');
	my ($val) = @_;
	my $res = $parser->parse_datetime($val) or die "Could not parse exif date '$val'\n";
	$res->set_formatter($formatter);
	return $res;
}

sub datetime_flickr {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	my ($val) = @_;
	my $res;
	if ($val =~ /^\d+$/) {
		$res = DateTime->from_epoch(epoch => $val);
	} else {
		($res = $formatter->parse_datetime($val)) or die "Could not parse flickr date '$val'\n";
	}
	$res->set_formatter($formatter);
	return $res;
}

sub add_keys {
	my ($keys, $gen) = @_;
	return sub {
		my $row = $gen->();
		return undef unless $row;
		$row->{$_} = $keys->{$_} foreach keys %$keys;
		return $row;
	}
}

sub flickr_photosets_list {
	my $album = regex_search($opts->{album});
	my $id = $opts->{ickr_id};
	my $args = {@_};
	my $total = $args->{total};
	delete $args->{total} if $album;
	my $num;
	my $all = flickr_select('photosets.getList', $args);
	return sub {
		my $row;
		return undef if $total && $num >= $total;
		while ($row = $all->()) {
			next if $id && $row->{id} ne $id;
			next if $album && $row->{title} !~ /$album/i;
			$num++;
			return $row;
		}
		return undef;
	}
}

sub with_progressbar {
	my ($gen) = @_;
	my ($bar, $oldtitle, $wrote_newline, $text);
	$| = 1;
	return sub {
		my $val = $gen->();
		unless (defined $val) {
			print "\n" unless $wrote_newline++;
			return undef;
		}
		if ($oldtitle && $val->{photoset}{title} ne $oldtitle or !$bar) {
			print "\n" if $bar;
			$text = $val->{photoset}{title} // $text;
			if (!$text) {
				if ($val->{path}) {
					$text = 'Images';
				} elsif ($val->{images}) {
					$text = 'Albums';
				} elsif ($val->{photos}) {
					$text = 'Photosets';
				} else {
					$text = 'Photos';
				}
			}
			$bar = String::ProgressBar->new(
				max    => $val->{total},
				length => 40,
				text   => encode(locale => sprintf("%20.20s", $val->{photoset}{title} ? $val->{photoset}{title} : $text) . ": "),
			);
		}
		$oldtitle = $val->{photoset}{title};
		$bar->update($val->{num});
		$bar->info(encode(locale => $val->{title})) if $val->{title};
		$bar->write;
		return $val;
	}
}

sub parallelize {
	my ($gen) = @_;
	my $channel = Coro::Channel->new();
	my $active_coros = 10;
	foreach my $i (0..($active_coros-1)) {
		async {
			my $next;
			do {
				$next = $gen->();
				$channel->put($next) if $next;
			} while ($next);
			$active_coros--;
			$channel->shutdown unless $active_coros;
		}
	}
	return sub { $channel->get };
}

sub one_element {
	my ($el) = @_;
	return sub {my $r = $el; $el = undef; return $r;};
}

sub flickr_get_photo {
	my ($id) = @_;
	my $photo = flickr_api('photos.getInfo', 'photo_id' => $id);
	$photo->{total} = $photo->{num} = 1;
	$photo->{datetaken} = $photo->{dates}{taken};
	$photo->{dateupload} = $photo->{dateuploaded};
	delete $photo->{dateuploaded};
	$photo->{datetakengranularity} = $photo->{dates}{takengranularity};
	delete $photo->{dates};
	$photo->{$_} = $photo->{visibility}{$_} foreach keys %{$photo->{visibility}};
	delete $photo->{visibility};
	$photo->{owner} = $photo->{owner}{nsid};
	$photo->{tags} = join ",", map {$_->{_content}} values %{$photo->{tags}};
	return $photo;
}

sub flickr_photos_list {
	my ($sets, $gen);
	if ($opts->{ickr_id}) {
		eval {
			($gen = one_element(flickr_get_photo($opts->{ickr_id})))
				|| ($sets = one_element(flickr_api('photosets.getInfo', 'photoset_id' => $opts->{ickr_id})));
		};
		unless ($gen || $sets) {
			warn $gen;
			warn $sets;
			die "No photo or photoset with id $opts->{ickr_id} found.";
		}
	} elsif ($opts->{album}) {
		$sets = flickr_photosets_list();
	}

	if ($sets) {
		my ($photos, $set, $num);
		my $semaphore = Coro::Semaphore->new();
		$sets = flickr_filter_photosets($sets);

		$gen = sub {
			while(1) {
				my $guard = $semaphore->guard();
				return undef if !$set && !($set = $sets->());
				if (!$photos) {
					$photos = add_keys(
						{photoset => $set},
						flickr_select(
							'photosets.getPhotos',
							{photoset_id => $set->{id}, extras => 'date_taken,date_upload,tags,view', @_}
						)
					);
				}
				my $photo = $photos->();
				return $photo if $photo;
				$set = undef; $photos = undef;
			}
		};

		my @photos;
		while (my $photo = $gen->()) {
			push @photos, $photo;
		}
		@photos = sort {$a->{datetaken} cmp $b->{datetaken}} @photos;
		@photos = @photos[0..($opts->{num}-1)] if $opts->{num};
		$gen = sub { return shift @photos };

	} elsif (!$gen) {
		if ($opts->{title} && $opts->{title} =~ /^[\w\s_]+$/ && $opts->{word}) {
			$gen = flickr_select(
				'photos.search',
				{user_id => 'me', sort => 'date-taken-asc', extras => 'date_taken,date_upload,tags,views', text => $opts->{title}}
			);
		} else {
			warn "Using complex --title or omitting --word causes slow scan of *all* the photos in the flickr account!\n" if $opts->{title};
			$gen = flickr_select(
				'people.getPhotos',
				{user_id => 'me', sort => 'date-taken-asc', extras => 'date_taken,date_upload,tags,views', @_, total => $opts->{num}},
			);
		}
	}

	return flickr_filter_photos($gen);
}

sub regex_search {
	my ($search) = @_;
	$search = "\\b$search\\b" if $search and $opts->{word};
	return $search ? qr/$search/i : undef;
}

sub flickr_filter_photosets {
	my ($gen) = @_;
	my $album = regex_search($opts->{album});
	return sub {
		while (1) {
			my $set = $gen->();
			return undef unless $set;
			next unless !$opts->{ickr_id} or $set->{ickr_id} == $opts->{ickr_id};
			next unless !$album or $set->{title} =~ $album;
			return $set;
		}
	}
}

sub flickr_filter_photos {
	my ($gen) = @_;
	my $title   = regex_search($opts->{title});
	my $album   = regex_search($opts->{album});
	my $ickr_id = $opts->{ickr_id};
	return sub {
		while (1) {
			my $photo = $gen->();
			return undef unless $photo;
			next if $title   && $photo->{title}           !~ $title;
			next if $ickr_id && $photo->{id}              ne $ickr_id;
			next if $album   && $photo->{photoset}{title} !~ $album;
			return $photo;
		}
	}
}

sub flickr_add_contexts {
	my ($gen) = @_;
	return sub {
		my $photo = $gen->();
		return undef unless $photo;
		my $response = flickr_photos('getAllContexts', $photo);
		$photo->{contexts} = [values %$response];
		return $photo;
	}
}

sub flickr_add_exif {
	my ($gen) = @_;
	return sub {
		my $photo = $gen->();
		return undef unless $photo;
		my $response = flickr_photos('getExif', $photo);
		my $tagtable = Image::ExifTool::GetTagTable('Image::ExifTool::Exif::Main');
		if ($response->{exif} and ref $response->{exif} eq 'ARRAY') {
			foreach my $tag (@{$response->{exif}}) {
				my ($info) = Image::ExifTool::GetTagInfoList($tagtable, $tag->{tag});
				$photo->{exif}{$info->{Name} || $tag->{tag}} = $tag->{raw};
			}
		}
		return $photo;
	}
}

sub flickr_add_photo_info {
	my ($gen) = @_;
	return sub {
		my $rec = $gen->();
		return undef unless $rec;
		my $photo = $rec->{flickr} || $rec;
		return $rec unless $photo->{server};
		$photo->{info} = flickr_photos('getInfo', $photo);
		$photo->{info}{people}{list} = $photo->{info}{people}{haspeople}
		                               ? ${flickr_photos('people.getList', $photo)}{person}
		                               : {};
		return $rec;
	}
}

sub flickr_add_photoset_info {
	my ($gen) = @_;
	return sub {
		my $photoset = $gen->();
		return undef unless $photoset;
		$photoset->{info} = flickr_photosets('getInfo', $photoset);
		my $photos = flickr_select('photosets.getPhotos', {photoset_id => $photoset->{id}, extras => ''});
		while (my $photo = $photos->()) {
			$photoset->{info}{order}[$photo->{num}-1] = $photo->{id};
			$photoset->{info}{primary} = $photo->{id} if $photo->{isprimary};
		}
		return $photoset;
	}
}

sub flickr_fix {
	my $auth = flickr_auth();
	my $me = flickr_api('people.getInfo', user_id => $auth->{user}{nsid});
	my $profile_html = get($me->{profileurl});
	$profile_html =~ m{<dt>Joined:</dt>\n\s*<dd>(.*?)</dd>}
		or die "Could not get joined date!\n";
	my $joindate = DateTime::Format::Flexible->parse_datetime($1);
	$joindate->add(months => 1);
	my $photo;
	warn "Will only set date_posted after found join date: " . $joindate . "\n";
	my $ickr = parallelize(flickr_add_exif(with_progressbar(flickr_photos_list())));
	while ($photo = $ickr->()) {
		my %update;
		my $exif_date_str  = $photo->{exif}{DateTimeOriginal} || $photo->{exif}{ModifyDate};
		my $exif_date      = datetime_exif($exif_date_str) if $exif_date_str;
		next unless $exif_date;
		my $datetaken  = datetime_flickr($photo->{datetaken});
		my $dateupload = datetime_flickr($photo->{dateupload});
		if (abs(($exif_date - $datetaken)->in_units('seconds')) > 1) {
			$update{date_taken} = "" . $exif_date;
		}
		if ($opts->{'fix-date-upload'}) {
			my $correct_dateupload = $update{date_taken} ? $exif_date->epoch : $datetaken->epoch;
			$correct_dateupload = max($joindate->epoch(), $correct_dateupload);
			if ($dateupload->epoch != $correct_dateupload) {
				$update{date_posted} = $correct_dateupload;
			}
		}
		flickr_photos('setDates', $photo, %update)
			if (%update);
	}
}

sub flickr_backup {
	my $path = shift() or die "No path for backup file given!\n";
	my $file;
	if ($path eq "-") {
		open $file, '>&:encoding(utf-8)', 'STDOUT';
	} else {
		die "Will not overwrite existing file $path!\n" if -e $path && !$opts->{force};
		open $file, ">:encoding(UTF-8)", $path;
	}

	$file->print(Dump($opts));
	$file->print(Dump(undef));

	my $photos = parallelize(flickr_add_photo_info(with_progressbar(flickr_photos_list(extras => ''))));
	my (@photosets_list, %photosets_hash);
	while (my $photo = $photos->()) {
		my $backup = {%$photo, %{$photo->{info}}};
		delete $backup->{info};
		$file->print(Dump($backup));
		if (%{$photo->{photoset}}) {
			my $id = $photo->{photoset}{id};
			push @photosets_list, $id unless $photosets_hash{$id};
			$photosets_hash{$id} ||= {%{$photo->{photoset}}};
			$photosets_hash{$id}{order}[$photo->{num}-1] = $photo->{id};
		}
	}
	$file->print(Dump(undef));

	my $photosets = parallelize(flickr_add_photoset_info(with_progressbar(
		@photosets_list ? sub {$photosets_hash{shift @photosets_list}}
		                : flickr_photosets_list(),
	)));
	while (my $photoset = $photosets->()) {
		my $backup = {%$photoset, %{$photoset->{info}}};
		delete $photoset->{info};
		$file->print(Dump($backup));
	}
	$file->close();
}

sub flickr_restore {
	my %byid;
	my $path = shift() or die "No path for backup file given!\n";
	my ($opts_yaml, $photo_backups_yaml, $photoset_backups_yaml) =
		map {my @res = split "---", $_; shift @res; \@res;} split("--- ~", decode_utf8(read_file($path)));
	$opts = {%$opts, %{Load($opts_yaml->[0])}};

	my $photo_backups = parallelize(
		flickr_add_photo_info(
			flickr_filter_photos(
				with_progressbar(sub { Load(shift $photo_backups_yaml) })
			)
		)
	);

	while (my $old = $photo_backups->()) {
		my $new = $old->{info};

		if (!$new) {
			warn "Photo with id $old->{id} not found\n";
			continue;
		}

		if ($old->{title} ne $new->{title} || $old->{description} ne $new->{description}) {
			flickr_photos_selected('setMeta', $old, title => $old->{title}, description => $old->{description});
		}

		my %setdates;
		if ($old->{dates}{posted} ne $new->{dates}{posted}) {
			$setdates{date_posted} = $old->{dates}{posted};
		}
		if ($old->{dates}{taken} ne $new->{dates}{taken}) {
			$setdates{date_taken} = $old->{dates}{taken};
		}
		if ($old->{dates}{takengranularity} ne $new->{dates}{takengranularity}) {
			$setdates{date_taken_granularity} = $old->{dates}{takengranularity};
		}
		if (%setdates) {
			flickr_photos_selected('setDates', $old, %setdates);
		}

		if ($old->{safety_level} != $new->{safety_level}) {
			flickr_photos_selected('setSafetyLevel', $old, safety_level => $old->{safety_level} + 1);
		}

		if ($old->{license} != $new->{license}) {
			flickr_photos_selected('licenses.setLicense', $old, license_id => $old->{license});
		}

		if ($new->{location} && !$old->{location}) {
			flickr_photos_selected('geo.removeLocation', $old);
		} else {
			if (any {$old->{location}{$::_} ne $new->{location}{$::_}} qw/longitude latitude context accuracy/) {
				flickr_photos_selected('geo.setLocation', $old, lon => $old->{location}{longitude}, lat => $old->{location}{latitude}, context => $old->{location}{context}, accuracy => $old->{location}{accuracy});
			}
			my @fields = qw(contact family friend public);
			if (any {$old->{geoperms}{'is' . $::_} ne $new->{geoperms}{'is' . $::_}} @fields) {
				flickr_photos_selected('geo.setPerms', $old, map {'is_' . $_ => $old->{geoperms}{'is' . $_}} @fields);
			}
		}

		if (join(" ", sort keys $old->{tags}) ne join(" ", sort keys $new->{tags})) {
			my $tagstring = join(" ", map {'"' . $_->{raw} . '"'} values $old->{tags});
			flickr_photos_selected('setTags', $old, tags => $tagstring);
		}
		if (any {$old->{permission}{$::_} ne $new->{permissions}{$::_}} qw/permaddmeta permcomment/,
			&& any {$old->{visibility}{$::_} ne $new->{visibility}{$::_}} qw/isfamily isfriend ispublic/,
		) {
			flickr_photos_selected(
				'setPerms', $old,
				map {'is_' . $_ => $old->{visibility}{'is' . $_}} qw/public friend family/,
				map {'perm_' . $_ => $old->{permissions}{'perm' . $_}} qw/comment addmeta/,
			);
		}

		my ($score_matrix, $allscores) = ({}, {});
		my %weight = (id => 100, content => 3, x => 2, y => 2, w => 1, h => 1);
		foreach my $n (values $old->{notes}) {
			foreach my $m (values $new->{notes}) {
				my $score = sum(map {$weight{$_}} grep {$n->{$_} eq $m->{$_}} qw/id x y h w _content/);
				if ($score > 0) {
					$score_matrix->{$n->{id}}{$m->{id}} = $score;
					$allscores->{$score}++;
				}
			}
		}
		if (!$opts->{select} || "notes" =~ /$opts->{select}/) {
			foreach my $score (sort {$b <=> $a} keys $allscores) {
				foreach my $n (values $old->{notes}) {
					my $m = first {$score_matrix->{$n->{id}}{$::_->{id}} == $score} values $new->{notes};
					next unless $m;
					delete $old->{notes}{$n->{id}};
					delete $new->{notes}{$m->{id}};
					next unless any {$n->{$::_} ne $m->{$::_}} qw/_content x y w h/;
					flickr_photos('notes.edit', $old, note_id => $m->{id}, note_text => $n->{_content}, map {'note_' . $_ => => $n->{$_}} qw/x y w h/);
				}
			}
			foreach my $n (values $old->{notes}) {
				flickr_photos('notes.add', $old, note_text => $n->{_content}, map {'note_' . $_ => => $n->{$_}} qw/x y w h/);
			}
			foreach my $m (values $new->{notes}) {
				flickr_api('photos.notes.delete', note_id => $m->{id});
			}
		}

		if (!$opts->{select} || "people" =~ /$opts->{select}/) {
			foreach my $p (values $old->{people}{list}) {
				my $q = $new->{people}{list}{$p->{nsid}};
				my %coords = map { 'person_' . $_ => $p->{$_} } qw/x y h w/;
				if (!$q) {
					flickr_photos('people.add', $old, 'user_id' => $p->{nsid}, %coords);
				} elsif (all {!defined $p->{$::_}} qw/x y h w/ and any {defined $q->{$::_}} qw/x y h w/) {
					flickr_photos('people.deleteCoords', $old, 'user_id' => $p->{nsid});
				} elsif (any {$p->{$::_} ne $q->{$::_}} qw/x y h w/) {
					flickr_photos('people.editCoords', $old, 'user_id' => $p->{nsid}, %coords);
				}
			}
			if ($new->{people}{list}) {
				foreach my $q (values $new->{people}{list}) {
					unless ($old->{people}{list}{$q->{nsid}}) {
						flickr_photos('people.delete', $old, 'user_id' => $q->{nsid});
					}
				}
			}
		}
	}

	my $photoset_backups = parallelize(
		flickr_add_photoset_info(
			with_progressbar(
				flickr_filter_photosets( sub {
					state $i = 0;
					my $res = Load($photoset_backups_yaml->[$i++]);
					return undef unless $res;
					$res->{total} = +@$photoset_backups_yaml;
					$res->{num} = $i;
					return $res;
				})
			)
		)
	);

	while (my $old = $photoset_backups->()) {
		my $new = $old->{info};

		my %update_photos;

		my $oldorder = join(",", @{$old->{order}});
		if ($oldorder ne join(",", @{$new->{order}}) && (!$opts->{select} || 'photo_ids' =~ /$opts->{select}/)) {
			$update_photos{photo_ids} = $oldorder;
		}
		if ($old->{primary} ne $new->{primary} && (!$opts->{select} || 'primary_photo_id' =~ /$opts->{select}/)) {
			$update_photos{primary_photo_id} = $old->{primary};
		}
		if ($update_photos{photo_ids}) {
			flickr_photosets('editPhotos', $old, %update_photos);
		} elsif (%update_photos) {
			flickr_photosets('setPrimaryPhoto', $old, photo_id => $update_photos{primary_photo_id});
		}

		my %update_meta;
		foreach my $k (qw/title description/) {
			if ($old->{$k} ne $new->{$k} && (!$opts->{select} || $k =~ /$opts->{select}/)) {
				$update_meta{$k} = $old->{$k};
			}
		}
		if (%update_meta) {
			flickr_photosets('editMeta', $old, %update_meta);
		}
	}
}

sub apickr_perms_from_ap {
	my ($ap, $ickr) = @_;

	my %keywords;
	$keywords{$_}++ foreach split ",", $ap->{keywords};

	my $num = 0;
	my $perm_comment = 3; # recommended default for flickr
	my $perm_addmeta = 2; # dito
	foreach my $perm (qw/nobody friends_and_family contacts everybody/) {
		$perm_comment = $num if $keywords{'flickr:comment=' . $perm};
		$perm_addmeta = $num if $keywords{'flickr:addmeta=' . $perm};
		$num++;
	}
	if ( (any {$keywords{'flickr:' . $::_} != $ickr->{'is' . $::_}} qw/family friend public/)
		 || $perm_comment != $ickr->{info}{permissions}{permcomment}
		 || $perm_addmeta != $ickr->{info}{permissions}{permaddmeta}
		) {
		return {
			(map {'is_' . $_ => 0+$keywords{'flickr:' . $_}} qw/family friend public/),
			'perm_comment' => $perm_comment,
			'perm_addmeta' => $perm_addmeta,
		}
	} else {
		return undef;
	}
}

sub apickr_tags_from_ap {
	my ($ap, $ickr) = @_;

	state ($gottags, %rawtags, %cleantags);
	if (!$gottags) {
		my $auth = flickr_auth();
		my $tags = flickr_api('tags.getListUserRaw', user_id => $auth->{user}{nsid});
		my (%rawtags, %cleantags);
		foreach my $tag (@{$tags->{tags}}) {
			$rawtags{$tag->{clean}} = $tag->{raw}[0];
			$cleantags{$_} = $tag->{clean} foreach @{$tag->{raw}};
		}
		$gottags = 1;
	}

	my ($changed, $stars, %tags, %keywords, %rating_tags);

	$keywords{$_}++ foreach split ",", $ap->{keywords};
	$tags{$_}++     foreach split / /, $ickr->{tags};

	for ($stars = 1; $stars <= min(4, $ap->{mainRating}); $stars++) {
		my $tag = 'aperture:rating=' . $stars . 'ormore';
		$rating_tags{$tag}++;
	}
	$rating_tags{'aperture:rating=' . $ap->{mainRating}}++;

	foreach my $tag (keys %keywords) {
		if ($tag !~ /^flickr:/) {
			my $clean = $cleantags{$tag} // $tag;
			$changed = $changed || !$tags{$clean};
			$tags{$clean}++;
		}
	}
	$tags{$_}++ foreach keys %rating_tags;

	foreach my $tag (keys %tags) {
		my $raw = $rawtags{$tag} // $tag;
		if (!$keywords{$raw} && !$rating_tags{$tag}) {
			$changed = 1;
			delete $tags{$tag};
		}
	}

	if ($changed) {
		return join(" ", map {'"' . ($rawtags{$_} // $_) . '"'} sort (keys %tags));
	} else {
		return undef;
	}
}

sub apickr_match {
	my ($ap_gen, $ickr_gen) = @_;

	my $ickr = $ickr_gen->();
	my $ap;

	return sub {
		while ($ap = $ap_gen->()) {
			while ($ickr and %$ickr and $ickr->{datetaken} lt $ap->{imageDate}) {
				$ickr = $ickr_gen->();
			}
			if ($ickr and %$ickr and $ickr->{datetaken} eq $ap->{imageDate}) {
				$ap->{flickr} = $ickr;
				$ap->{total} = $ap->{num} = 1 if $opts->{ickr_id};
			}
			return $ap unless $opts->{ickr_id} && !$ap->{flickr};
		}
		return undef;
	}
}

sub apickr_sync {
	my $ap_gen   = aperture_select_images();
	my $ickr_gen = flickr_add_contexts(with_progressbar(flickr_photos_list(), 'Photos'));
	my $match    = apickr_match($ap_gen, $ickr_gen);

	my $sets;
	my $gen = flickr_photosets_list();
	while (my $set = $gen->()) {
		$sets->{$set->{title}} = $set;
	}

	my $sync_all = sub {
		while (1) {
			my $ap;
			do {
				$ap = $match->();
			} while $ap && !$ap->{flickr} && !$opts->{upload};
			last unless $ap;
			my $ickr = $ap->{flickr};

			my $settags  = apickr_tags_from_ap($ap, $ickr);
			my $setperms = apickr_perms_from_ap($ap, $ickr);

			if (!$ickr) {
				# hardcoded default defaults from flickr, should check if user changed them...
				delete $setperms->{perm_comment} if $setperms->{perm_comment} == 3;
				delete $setperms->{perm_addmeta} if $setperms->{perm_addmeta} == 2;
				my $coro = flickr_photos_selected(
					'upload',
					{},
					title       => $ap->{name},
					description => $ap->{caption},
					tags        => $settags,
					(map {$_ => delete $setperms->{$_}} qw/is_family is_friend is_public/),
					photo       => $ap->{path},
					);
				$settags = undef;
				$ickr = {id => $coro->join()->{photoid}};
			} else {
				if ($ap->{name} ne $ickr->{title} || $ap->{caption} ne $ickr->{description}) {
					flickr_photos_selected('setMeta', $ickr, title => $ap->{name}, description => $ap->{caption});
				}

				if ($settags) {
					flickr_photos_selected('setTags', $ickr, tags => $settags);
				}
			}

			if ($setperms) {
				flickr_photos_selected('setPerms', $ickr, %$setperms);
			}

			my $gotalbum = 0;
			foreach my $context (@{$ickr->{contexts}}) {
				if ($context->{title} eq $ap->{album}) {
					$gotalbum = 1;
				}
			}
			if (!$gotalbum) {
				my $set = $sets->{$ap->{album}};
				if (!$set) {
					$set = flickr_photosets('create', {}, 'title' => $ap->{album}, 'primary_photo_id' => $ickr->{id});
					$sets->{$ap->{album}} = $set;
				} else {
					flickr_photosets('addPhoto', $set, 'photo_id' => $ickr->{id});
				}
			}

			return $ap;
		}
	};

	$sync_all = parallelize($sync_all);

	while ($sync_all->()) {};
}

sub display {
	my ($gen) = @_;

	my $regex = $opts->{select} // '\b\B';

	if ($opts->{verbose}) {
		$regex = '.';
	} elsif (!$opts->{count} || !$opts->{select}) {
		$regex .= '|^\.('
			. '((flickr\.)?(title|photoset\.title|contexts\.title|info\.people\.list\.(.*)\.username|datetaken|tags|views|sets|exif))' #flickr photos keys
			. '|photos|count_views|count_comments'                                 #flickr photoset keys
			. '|imageDate|imagePath|keywords|mainRating|name|path|versionNumber'   #aperture image keys
			. '|album|stacks|images'                                               #aperture album keys
			. ')\b';
	}

	my $select = qr/$regex/i;
	my $filter = $opts->{filter} ? qr/$opts->{filter}/i : qr/./;
	my $walk;
	$walk = sub {
		my ($prefix, $data) = @_;
		my ($result, $result_match) = (undef, 0);
		given (ref $data) {
			when ('HASH') {
				foreach my $key (keys $data) {
					my ($val, $match) = $walk->($prefix . "." . $key, $data->{$key});
					$result_match ||= $match;
					$result->{$key} = $val if defined $val;
				}
			}
			when ('ARRAY') {
				foreach my $val (@$data) {
					my ($new, $match) = $walk->($prefix, $val);
					$result_match ||= $match;
					push @$result, $new if defined $new;
				}
			}
			default {
				$result_match ||= ($data && ($prefix ~~ $filter || $data ~~ $filter));
				$result = $prefix ~~ $select ? $data : undef;
			}
		}
		return ($result, $result_match);
	};

	$gen = with_progressbar($gen) if $opts->{count} or $opts->{classify};

	my $oldgen = $gen;
	$gen = sub {
		my $row;
		while ($row = $oldgen->()) {
			my ($new, $match) = $walk->('', $row);
			return $new if $new and ($opts->{not} ? !$match : $match);
		}
		return $row;
	};

	if ($opts->{count}) {
		my $count = 0;
		while (my $row = $gen->()) {
			$count++;
		}
		say $count;
	} elsif ($opts->{classify}) {
		my %counts;
		while (my $row = $gen->()) {
			$counts{$row->{$opts->{classify}}}++;
		}
		my $maxlen = max map {length $_} keys %counts;
		say sprintf("%-${maxlen}s :   %s", $_, $counts{$_}) foreach sort keys %counts;
	} else {
		say d($_) while $_ = $gen->();
	}
}

sub d {
	my ($row) = @_;
	return Dump(encode_rec($row));
}

sub pd {
	my ($gen) = @_;
	return sub {
		my $next = $gen->();
		say d($next) if $next;
		return $next;
	}
}

sub encode_rec {
	my ($in) = @_;
	given (ref $in) {
		when ('HASH')  { return {map {$_ => encode_rec($in->{$_})} keys %$in} };
		when ('ARRAY') { return [map {encode_rec($_)} @$in] };
		default        { return $in ? encode(locale => $in) : $in }
	}
}

