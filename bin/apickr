#!/usr/bin/env perl

=head1 NAME

apickr - Synchronize aperture library and flickr account.

=head1 SYNOPSIS

apickr [OPTIONS] COMMAND PATH

Synchronize aperture library given by PATH with flickr.

=head1 COMMANDS

  albums              list albums
  images              list images
  flickr              sync with flickr
  flickr-fix          fix flickr dates from exif
  flickr-photosets    list flickr photosets
  flickr-images       list flickr images
  flickr-backup PATH  backup metadata for selected images to PATH
  flickr-restore PATH restore metadata for selected images from PATH

=head1 OPTIONS

 --help|-h         brief help message
 --num=NUM         only process NUM items
 --album|-a=REGEX  only process Aperture Albums/Flickr Photosets which match REGEX
 --title|-t=REGEX  only process Images which match REGEX
 --word|-w         only match album or title at word boundaries
 --id              only process photo/album with this id
 --verbose|-v      output verbose information
 --select|-s       regex to select *additional* keys to output
 --dry-run|-n      only output changes to flickr data
 --force|-f        overwrite already existing backups with flickr-backup
 --exif            add exif data to images

=head1 AUTHOR

 Nathan Gass <gass@search.ch>

=cut

use Modern::Perl;
use autodie;
use common::sense;

use Getopt::Long qw/:config/;
use Pod::Usage;
use YAML qw/LoadFile DumpFile Load Dump/;
use DBI;
use Flickr::API2;
use File::Spec::Functions qw/splitpath catdir/;
use Browser::Open qw/open_browser/;
use List::AllUtils qw/first max min any all sum/;
use Encode qw/encode_utf8 decode_utf8 encode decode/;
use Encode::Locale;
use DateTime;
use DateTime::Format::Strptime;
use DateTime::Format::Epoch;
use Carp qw/confess/;
use String::ProgressBar;
use File::Slurp;
use Image::ExifTool qw/ImageInfo/;

my @podargs = (-verbose => 99, -sections => [qw/NAME SYNOPSIS COMMANDS OPTIONS/]);
my $config = {};
{
	local $@;
	eval {
		$config = LoadFile(catdir($ENV{HOME}, '.apickrrc'));
	};
}
my $opts = {};
GetOptions(
	$opts,
	'help|h', 'num=i', 'album|a=s', 'title|t=s', 'word|t', 'id=s', 'verbose|v', 'select|s=s', 'dry-run|n', 'force|f', 'exif',
	) or pod2usage(-exitval => 2, @podargs);
pod2usage(@podargs) if $opts->{help};
$config = {%$config, %$opts};

my $command = shift() || "albums";
my $path;
if ($command !~ /^flickr-/) {
	$path = shift() || catdir($ENV{HOME}, 'Pictures', '2 Sterne.aplibrary');
}

given ($command) {
	when ("albums") {
		display(aperture_select(
			"RKFolder.name AS album,COUNT(DISTINCT COALESCE(RKVersion.stackUuid,RKVersion.uuid)) AS stacks,COUNT(DISTINCT RKVersion.uuid) AS images",
			"GROUP BY RKVersion.projectUuid"
		));
	}
	when ("images") {
		my $gen = aperture_select(
			"RKVersion.uuid,RKFolder.name AS album,RKVersion.name,imagePath,mainRating,versionNumber,RkVersion.imageDate"
		);
		$gen = aperture_add_exif($gen)
			if $opts->{exif};
		display($gen);
	}
	when ("flickr") {
	}
	when ("flickr-backup") {
		my $path = shift() or die "No path for backup file given!\n";
		die "Will not overwrite existing file $path!\n" if -e $path && !$opts->{force};
		open my $file, ">", $path;
		$file->print(encode_utf8(Dump($opts)));
		$file->print(Dump(undef));
		my $photos = with_progressbar(flickr_images(extras => ''), 'Photos');
		my (@photosets_list, %photosets_hash);
		while (my $photo = $photos->()) {
			my $backup = flickr_photo_backup($photo);
			$file->print(encode_utf8(Dump($backup)));
			if (%{$photo->{photoset}}) {
				my $id = $photo->{photoset}{id};
				push @photosets_list, $id unless $photosets_hash{$id};
				$photosets_hash{$id} ||= $photo->{photoset};
				$photosets_hash{$id}{order}[$photo->{num}-1] = $photo->{id};
			}
		}
		$file->print(Dump(undef));
		my $photosets = with_progressbar(
			@photosets_list ? sub {$photosets_hash{shift @photosets_list}}
			                : flickr_photosets_list(),
			'Photosets',
		);
		while (my $photoset = $photosets->()) {
			my $backup = flickr_photoset_backup($photoset);
			$file->print(encode_utf8(Dump($backup)));
		}
		$file->close();
	}

	when ("flickr-restore") {
		my %byid;
		my $path = shift() or die "No path for backup file given!\n";
		my ($opts_yaml, $photo_backups_yaml, $photoset_backups_yaml) =
			map {my @res = split "---", $_; shift @res; \@res;} split("--- ~", decode_utf8(read_file($path)));
		$opts = {%$opts, %{Load($opts_yaml->[0])}};
		my $photo_backups = with_progressbar(sub { Load(shift $photo_backups_yaml) }, 'Photos');
		my $photoset_backups = with_progressbar(sub {
			state $i = 0;
			my $res = Load($photoset_backups_yaml->[$i++]);
			return undef unless $res;
			$res->{total} = +@$photoset_backups_yaml;
			$res->{num} = $i;
			return $res;
		}, 'Photosets');
		while (my $old = $photo_backups->()) {
			my $new = flickr_photo_backup({id => $old->{id}});

			if (!$new) {
				warn "Photo with id $old->{id} not found\n";
				continue;
			}

			if ($old->{title} ne $new->{title} || $old->{description} ne $new->{description}) {
				flickr_photos('setMeta', $old, title => $old->{title}, description => $old->{description});
			}

			if ($old->{safety_level} != $new->{safety_level}) {
				flickr_photos('setSafetyLevel', $old, safety_level => $old->{safety_level} + 1);
			}

			if ($old->{license} != $new->{license}) {
				flickr_photos('licenses.setLicense', $old, license_id => $old->{license});
			}

			if ($new->{location} && !$old->{location}) {
				flickr_photos('geo.removeLocation', $old);
			} else {
				if (any {$old->{location}{$::_} ne $new->{location}{$::_}} qw/longitude latitude context accuracy/) {
					flickr_photos('geo.setLocation', $old, lon => $old->{location}{longitude}, lat => $old->{location}{latitude}, context => $old->{location}{context}, accuracy => $old->{location}{accuracy});
				}
				my @fields = qw(contact family friend public);
				if (any {$old->{geoperms}{'is' . $::_} ne $new->{geoperms}{'is' . $::_}} @fields) {
					flickr_photos('geo.setPerms', $old, map {'is_' . $_ => $old->{geoperms}{'is' . $_}} @fields);
				}
			}

			if (join(" ", sort keys $old->{tags}) ne join(" ", sort keys $new->{tags})) {
				my $tagstring = join(" ", map {'"' . $_->{raw} . '"'} values $old->{tags});
				flickr_photos('setTags', $old, tags => $tagstring);
			}
			if (any {$old->{permission}{$::_} ne $new->{permissions}{$::_}} qw/permaddmeta permcomment/,
				&& any {$old->{visibility}{$::_} ne $new->{visibility}{$::_}} qw/isfamily isfriend ispublic/,
			) {
				flickr_photos(
					'setPerms', $old,
					map {'is_' . $_ => $old->{visibility}{'is' . $_}} qw/public friend family/,
					map {'perm_' . $_ => $old->{permissions}{'perm' . $_}} qw/comment addmeta/,
				);
			}

			my ($score_matrix, $allscores) = ({}, {});
			my %weight = (id => 100, content => 3, x => 2, y => 2, w => 1, h => 1);
			foreach my $n (values $old->{notes}) {
				foreach my $m (values $new->{notes}) {
					my $score = sum(map {$weight{$_}} grep {$n->{$_} eq $m->{$_}} qw/id x y h w _content/);
					if ($score > 0) {
						$score_matrix->{$n->{id}}{$m->{id}} = $score;
						$allscores->{$score}++;
					}
				}
			}
			foreach my $score (sort {$b <=> $a} keys $allscores) {
				foreach my $n (values $old->{notes}) {
					my $m = first {$score_matrix->{$n->{id}}{$::_->{id}} == $score} values $new->{notes};
					next unless $m;
					delete $old->{notes}{$n->{id}};
					delete $new->{notes}{$m->{id}};
					next unless any {$n->{$::_} ne $m->{$::_}} qw/_content x y w h/;
					flickr_photos('notes.edit', $old, note_id => $m->{id}, note_text => $n->{_content}, map {'note_' . $_ => => $n->{$_}} qw/x y w h/);
				}
			}
			foreach my $n (values $old->{notes}) {
				flickr_photos('notes.add', $old, note_text => $n->{_content}, map {'note_' . $_ => => $n->{$_}} qw/x y w h/);
			}
			foreach my $m (values $new->{notes}) {
				flickr_api('photos.notes.delete', note_id => $m->{id});
			}

			foreach my $p (values $old->{people}{list}) {
				my $q = $new->{people}{list}{$p->{nsid}};
				my %coords = map { 'person_' . $_ => $p->{$_} } qw/x y h w/;
				if (!$q) {
					flickr_photos('people.add', $old, 'user_id' => $p->{nsid}, %coords);
				} elsif (all {!defined $p->{$::_}} qw/x y h w/ and any {defined $q->{$::_}} qw/x y h w/) {
					flickr_photos('people.deleteCoords', $old, 'user_id' => $p->{nsid});
				} elsif (any {$p->{$::_} ne $q->{$::_}} qw/x y h w/) {
					flickr_photos('people.editCoords', $old, 'user_id' => $p->{nsid}, %coords);
				}
			}
			foreach my $q (values $new->{people}{list}) {
				unless ($old->{people}{list}{$q->{nsid}}) {
					flickr_photos('people.delete', $old, 'user_id' => $q->{nsid});
				}
			}
		}

		while (my $old = $photoset_backups->()) {
			my $new = flickr_photoset_backup({id => $old->{id}});
			my $oldorder = join(",", @{$old->{order}});
			if ($oldorder ne join(",", @{$new->{order}})) {
				flickr_photosets('editPhotos', $old, primary_photo_id => $old->{primary}, photo_ids => $oldorder);
			} elsif ($old->{primary} ne $new->{primary}) {
				flickr_photosets('setPrimaryPhoto', $old, photo_id => $old->{primary});
			}
			if ($old->{title} ne $new->{title} || $old->{description} ne $new->{description}) {
				flickr_photosets('editMeta', $old, title => $old->{title}, description => $old->{description});
			}
		}
	}


	when ("flickr-fix") {
		my $ickr = with_progressbar(flickr_add_exif(flickr_images()));
		my $photo;
		while ($photo = $ickr->()) {
			my %update;
			my $exif       = datetime_exif($photo->{exif}{DateTimeOriginal});
			my $datetaken  = datetime_flickr($photo->{datetaken});
			my $dateupload = datetime_flickr($photo->{dateupload});
			if (abs(($exif - $datetaken)->in_units('seconds')) > 1) {
				$update{date_taken} = "" . $exif;
			}
			if ($update{date_taken} && $dateupload != $exif || $dateupload != $datetaken) {
				$update{date_posted} = $update{date_taken} ? $exif->epoch : $datetaken->epoch;
			}
			flickr_photos('setDates', $photo, %update)
				if (%update);
		}
	}
	when ("flickr-photosets") {
		my $select = $opts->{select} // '\b\B';
		display(
			filter_keys(
				qr/^\.(id|title|photos|count_views|count_comments)\b|$select/,
				flickr_photosets_list(total => $opts->{num})
			),
		);
	}
	when ("flickr-images") {
		my $select = $opts->{select} // '\b\B';
		my $gen = flickr_images();
		if ($opts->{exif}) {
			$gen = flickr_add_exif($gen);
			$select .= '|^\.exif\.';
		}
		display(
			filter_keys(
				qr/^\.(title|photoset.title|datetaken|tags|views|sets)\b|$select/,
				$gen,
			)
		);
	}
	default {die "Unknown command $_"}
};

exit;

sub flickr_auth {
	my $api = shift;
	my $auth = {};
	my $authpath = catdir($ENV{HOME}, '.apickr.auth');
	if (-e $authpath) {
		$auth = LoadFile($authpath);
	}
	if (!$auth->{token}) {
		my $frob = flickr_api('auth.getFrob', api_key => $api->raw->{api_key});
		my $url = $api->raw->request_auth_url('write', $frob);
		open_browser($url);
		say "Please authorize apickr to read and write to your flickr account.";
		say "Press any key to continue.";
		local $| = 0;
		getc;
		$auth = flickr_api('auth.getToken', frob => $frob);
		DumpFile($authpath, $auth);
	}
	return $auth;
}

sub flickr_api {
	state $api = Flickr::API2->new({key => '04c25240b84f6f5d32e8e43fd4deb249', secret => 'abef06bf4946a4a2'});
	state $auth = flickr_auth($api);
	my $method = shift;
	my $params = {@_};
	$params->{auth_token} = $auth->{token}
		if $auth;
	my $req;
	if (($opts->{verbose} || $opts->{'dry-run'}) && $method =~ /\.(set|remove|delete|add|edit)/) {
		print "\n", 'flickr.' . $method, "\n", Dump($params), "\n";
		return undef if $opts->{'dry-run'};
	}
	eval {
		$req = $api->execute_method('flickr.' . $method, $params);
	};
	if ($@ && (!$params->{page} || $params->{page} == 1)) {
		confess $@
	}
	if ($req && $req->{stat} eq 'ok') {
		delete $req->{stat};
		if (%$req) {
			my ($first) = keys $req;
			return simplify_flickr_response($req->{$first}, $params->{page} ? 0 : 1);
		}
	}
	return undef;
}

sub flickr_photos {
	my ($method, $photo, @args) = @_;
	return flickr_api('photos.' . $method, photo_id => $photo->{id}, @args);
}

sub flickr_photosets {
	my ($method, $photoset, @args) = @_;
	return flickr_api('photosets.' . $method, photoset_id => $photoset->{id}, @args);
}

sub simplify_flickr_response {
	my ($r, $inarray, $inkey) = @_;
	my $singular = $1 if $inkey && $inkey =~ /^(\w+)s$/;
	given (ref $r) {
		when ('HASH') {
			if (exists $r->{_content} && keys($r) == 1) {
				return decode_utf8($r->{_content});
			} elsif ($singular && keys $r == 1 && defined($r->{$singular})) {
				return simplify_flickr_response($r->{$singular}, $inarray,);
			} else {
				return { map {$_ => simplify_flickr_response($r->{$_}, $inarray, $_)} keys %$r };
			}
		}
		when ('ARRAY') {
			if ($inarray && all {ref($::_) eq 'HASH' and $::_->{id} || $::_->{nsid}} @$r) {
				return { map {($_->{id} || $_->{nsid}) => simplify_flickr_response($_, $inarray)} @$r };
			} else {
				return [map {simplify_flickr_response($_, 1)} @$r];
			}
		}
		default {
			return decode_utf8($r);
		}
	}
}

sub flickr_select {
	my ($method, $args) = @_;
	my ($resp, $page, $key, $i);
	my $num = 1;
	my $total = $args->{total};
	delete $args->{total};
	$args->{per_page} = $total // 500;
	return sub {
		if (!$i || $i == @{$resp->{$key}}) {
			return undef if $key and @{$resp->{$key}} < 500 || $total;
			$args->{page} = ++$page;
			$resp = flickr_api($method, %$args);
			return undef unless $resp;
			$key = first {ref($resp->{$_}) eq 'ARRAY'} keys %$resp;
			return undef unless $key && @{$resp->{$key}};
			$i = 0;
		}
		my $res = $resp->{$key}[$i++];
		$res->{total} = $total // $resp->{total};
		$res->{num} = $num++;
		return $res;
	}
}

sub aperture_select {
	my ($select, $add) = @_;
	$add = "" unless $add;
	$select .= "," . $opts->{select} if $opts->{select};
	my $dbpath = catdir($path, 'Database', 'Library.apdb');
	my $dbh = DBI->connect("dbi:SQLite:dbname=$dbpath","", "", { RaiseError => 1, AutoCommit => 0, ReadOnly => 1});
	my $sql =
		"Select $select FROM RKVersion"
		. " JOIN RKFolder ON RKFolder.uuid = RKVersion.projectUuid"
		. " JOIN RKMaster ON RKVersion.masterUuid = RKMaster.uuid"
		. " WHERE RKVersion.isInTrash = 0 AND RKVersion.versionNumber > 0 AND RKFolder.folderType = 2 "
		. ($opts->{album} ? "AND RKFolder.name REGEXP ? " : '')
		. ($opts->{title} ? "AND RKVersion.name REGEXP ? " : '')
		. ($opts->{id}    ? "AND (RKFolder.uuid = ? OR RKVersion.uuid = ?) " : '')
		. $add
		. ($opts->{num}   ? " LIMIT ? " : '');
	my $sth = $dbh->prepare($sql);
	my $param = 1;
	$sth->bind_param($param++, $opts->{album}) if $opts->{album};
	$sth->bind_param($param++, $opts->{title}) if $opts->{title};
	if ($opts->{id}) {
		$sth->bind_param($param++, $opts->{id});
		$sth->bind_param($param++, $opts->{id});
	}
	$sth->bind_param($param++, $opts->{num}) if $opts->{num};
	$sth->execute();

	return sub {
		my $row = $sth->fetchrow_hashref;
		if ($row && $row->{imagePath}) {
			my ($d,$dir,$name) = splitpath($row->{imagePath});
			my $prev = catdir($path, 'Previews', $dir, $row->{uuid}, $row->{name} . ".jpg");
			$row->{path} = -e $prev ? $prev : catdir($path, 'Masters', $row->{imagePath});
		}
		if ($row && $row->{imageDate}) {
			$row->{imageDate} = datetime_aperture($row->{imageDate});
		}
		$dbh->disconnect unless $row;
		return $row;
	}
}

sub aperture_add_exif {
	my ($gen) = @_;
	return sub {
		my $row = $gen->();
		return undef unless $row;
		$row->{exif} = ImageInfo($row->{path});
		return $row;
	}
}

sub datetime_aperture {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	state $macepoch  = DateTime::Format::Epoch->new(
		epoch => DateTime->new(year => 2001, month => 1, day => 1),
		);
	my ($val) = @_;
	my $res = $macepoch->parse_datetime(shift) or die "Could not parse aperture date '$val'\n";
	$res->set_formatter($formatter);
	return $res;
}

sub datetime_exif {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	state $parser = DateTime::Format::Strptime->new(pattern => '%Y:%m:%d %H:%M:%S');
	my ($val) = @_;
	my $res = $parser->parse_datetime($val) or die "Could not parse exif date '$val'\n";
	$res->set_formatter($formatter);
	return $res;
}

sub datetime_flickr {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	my ($val) = @_;
	my $res;
	if ($val =~ /^\d+$/) {
		$res = DateTime->from_epoch(epoch => $val);
	} else {
		($res = $formatter->parse_datetime($val)) or die "Could not parse flickr date '$val'\n";
	}
	$res->set_formatter($formatter);
	return $res;
}

sub _filter_keys_rec {
	my ($prefix, $select, $data) = @_;
	my $result;
	given (ref $data) {
		when ('HASH') {
			foreach my $key (keys $data) {
				my $val = _filter_keys_rec($prefix . "." . $key, $select, $data->{$key});
				$result->{$key} = $val if defined $val;
			}
		}
		when ('ARRAY') {
			foreach my $val (@$data) {
				my $new = _filter_keys_rec($prefix, $select, $val);
				push $result, $new if defined $new;
			}
		}
		default {
			$result = $prefix ~~ $select ? $data : undef;
		}
	}
	return $result;
}
sub filter_keys {
	my ($select, $gen) = @_;
	return $gen if ($opts->{verbose});
	return sub {
		my $row = $gen->();
		return $row ? _filter_keys_rec('', $select, $row) : undef;
	}
}

sub add_keys {
	my ($keys, $gen) = @_;
	return sub {
		my $row = $gen->();
		return undef unless $row;
		$row->{$_} = $keys->{$_} foreach keys %$keys;
		return $row;
	}
}

sub flickr_photosets_list {
	my $album = $opts->{album};
	$album = "\\b$album\\b" if $opts->{word} and $album;
	my $id = $opts->{id};
	my $args = {@_};
	my $total = $args->{total};
	delete $args->{total} if $album;
	my $num;
	my $all = flickr_select('photosets.getList', $args);
	return sub {
		my $row;
		return undef if $total && $num >= $total;
		while ($row = $all->()) {
			next if $id && $row->{id} ne $id;
			next if $album && $row->{title} !~ /$album/i;
			$num++;
			return $row;
		}
		return undef;
	}
}

sub with_progressbar {
	my ($gen, $text) = @_;
	my ($bar, $oldtitle);
	$| = 1;
	return sub {
		my $val = $gen->();
		unless (defined $val) {
			print "\n";
			return undef;
		}
		if ($oldtitle && $val->{photoset}{title} ne $oldtitle or !$bar) {
			print "\n" if $bar;
			$bar = String::ProgressBar->new(
				max    => $val->{total},
				length => 40,
				text   => encode(locale => sprintf("%20.20s", $val->{photoset}{title} ? $val->{photoset}{title} : $text) . ": "),
			);
		}
		$oldtitle = $val->{photoset}{title};
		$bar->update($val->{num});
		$bar->info(encode(locale => $val->{title})) if $val->{title};
		$bar->write;
		return $val;
	}
}

sub one_element {
	my ($el) = @_;
	return sub {my $r = $el; $el = undef; return $r;};
}

sub flickr_images {
	my @args = @_;
	my $album = $opts->{album};
	$album = "\\b$album\\b" if $opts->{word} and $album;
	my $sets;
	if ($opts->{id}) {
		my $photo;
		eval {
			$photo = flickr_api('photos.getInfo', 'photo_id' => $opts->{id});
		};
		if ($photo) {
			$photo->{total} = $photo->{num} = 1;
			$photo->{datetaken} = $photo->{dates}{taken};
			$photo->{dateupload} = $photo->{dateuploaded};
			delete $photo->{dateuploaded};
			$photo->{datetakengranularity} = $photo->{dates}{takengranularity};
			delete $photo->{dates};
			$photo->{$_} = $photo->{visibility}{$_} foreach keys %{$photo->{visibility}};
			delete $photo->{visibility};
			$photo->{owner} = $photo->{owner}{nsid};
			$photo->{tags} = join ",", map {$_->{_content}} values %{$photo->{tags}};
			return one_element($photo);
		}
		my $photoset = flickr_api('photosets.getInfo', 'photoset_id' => $opts->{id});
		if ($photoset and !$album || $photoset->{title} =~ /$album/i) {
			$sets = one_element($photoset);
		}
	} elsif ($opts->{album}) {
		$sets = flickr_photosets_list();
	}

	my $gen;
	if ($sets) {
		my ($photos, $set, $num);
		$gen = sub {
			while(1) {
				return undef unless $set || ($set = $sets->()) && (!$opts->{num} || $num < $opts->{num});
				if (!$photos) {
					$photos = add_keys(
						{photoset => $set},
						flickr_select(
							'photosets.getPhotos',
							{photoset_id => $set->{id}, extras => 'date_taken,date_upload,tags,view', @args, total => $opts->{num}}
						)
						);
				}
				my $photo = $photos->();
				if ($photo) {
					$num++;
					return $photo;
				}
				$set = undef; $photos = undef;
			}
		}
	} elsif ($opts->{title} && $opts->{title} =~ /^[\w\s_]+$/ && $opts->{word}) {
		$gen = flickr_select(
			'photos.search',
			{user_id => 'me', sort => 'date-taken-asc', extras => 'date_taken,date_upload,tags,views', text => $opts->{title}}
		);
	} else {
		warn "Using complex --title or omitting --word causes slow scan of *all* the images in the flickr account!\n" if $opts->{title};
		$gen = flickr_select(
			'people.getPhotos',
			{user_id => 'me', sort => 'date-taken-asc', extras => 'date_taken,date_upload,tags,views', @args, total => $opts->{num}},
		);
	}
	if ($opts->{title}) {
		my $title = $opts->{title};
		$title = "\\b$title\\b" if $opts->{word};
		return sub {
			while (1) {
				my $photo = $gen->();
				return undef unless $photo;
				next unless $photo->{title} =~ /$title/i;
				return $photo;
			}
		}
	} else {
		return $gen;
	}
}

sub flickr_add_exif {
	my ($gen) = @_;
	return sub {
		my $photo = $gen->();
		return undef unless $photo;
		my $exif = flickr_photos('getExif', $photo);
		foreach my $tag (@{$exif->{exif}}) {
			$photo->{exif}{$tag->{tag}} = $tag->{raw};
		}
		return $photo;
	}
}

sub flickr_photo_backup {
	my ($photo) = @_;
	my $info = flickr_photos('getInfo', $photo);
	$photo->{$_} = $info->{$_} foreach keys $info;
	$photo->{people}{list} = $photo->{people}{haspeople} ? ${flickr_photos('people.getList', $photo)}{person} : {};
	return $photo;
}

sub flickr_photoset_backup {
	my ($photoset) = @_;
	my $info = flickr_photosets('getInfo', $photoset);
	$photoset->{$_} = $info->{$_} foreach keys $info;
	unless (defined $photoset->{order}) {
		my $photos = flickr_select('photosets.getPhotos', {photoset_id => $photoset->{id}, extras => ''});
		while (my $photo = $photos->()) {
			$photoset->{order}[$photo->{num}-1] = $photo->{id};
			$photoset->{primary} = $photo->{id} if $photo->{isprimary};
		}
	}
	return $photoset;
}

sub display {
	state $num = 0;
	my ($gen) = @_;
	my ($row, $n);
	say d($row) while $row = $gen->();
}

sub d {
	my ($row) = @_;
	return Dump(encode_rec($row));
}

sub encode_rec {
	my ($in) = @_;
	given (ref $in) {
		when ('HASH')  { return {map {$_ => encode_rec($in->{$_})} keys %$in} };
		when ('ARRAY') { return [map {encode_rec($_)} @$in] };
		default        { return $in ? encode(locale => $in) : $in }
	}
}

