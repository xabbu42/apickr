#!/usr/bin/env perl

=head1 NAME

apickr - Synchronize aperture library and flickr account.

=head1 SYNOPSIS

apickr [OPTIONS] COMMAND PATH

Synchronize aperture library given by PATH with flickr.

=head1 COMMANDS

  albums        list albums
  images        list images
  flickr        sync with flickr
  flickr-albums list flickr albums
  flickr-images list flickr images

=head1 OPTIONS

 --help|-h    brief help message
 --num|-n=NUM only process num items

=head1 AUTHOR

 Nathan Gass <gass@search.ch>

=cut

use Modern::Perl;
use autodie;

use Getopt::Long qw/:config/;
use Pod::Usage;
use YAML qw/LoadFile DumpFile Load Dump/;
use DBI;
use Flickr::API2;
use File::Spec::Functions qw/splitpath catdir/;
use Browser::Open qw/open_browser/;
use List::AllUtils qw/first max min/;
use Encode qw/encode_utf8/;
use DateTime;
use DateTime::Format::Strptime;
use DateTime::Format::Epoch;
use Carp qw/confess/;

my @podargs = (-verbose => 99, -sections => [qw/NAME SYNOPSIS COMMANDS OPTIONS/]);
my $config = {};
eval {
	$config = LoadFile(catdir($ENV{HOME}, '.apickrrc'));
};
my $opts = {};
GetOptions(
	$opts,
	"help|h", 'num|n=i',
	) or pod2usage(-exitval => 2, @podargs);
pod2usage(@podargs) if $opts->{help};
$config = {%$config, %$opts};

my $command = shift() || "albums";
my $path = shift() || catdir($ENV{HOME}, 'Pictures', '2 Sterne.aplibrary');

given ($command) {
	when ("albums") {
		display(aperture_select(
			"RKFolder.name AS album,COUNT(DISTINCT COALESCE(RKVersion.stackUuid,RKVersion.uuid)) AS stacks,COUNT(DISTINCT RKVersion.uuid) AS images", 
			"GROUP BY RKVersion.projectUuid"
		));
	}
	when ("images") {
		display(aperture_select(
			"RKVersion.uuid,RKFolder.name AS album,RKVersion.name,imagePath,mainRating,versionNumber,RkVersion.imageDate"
		));
	}
	when ("flickr") {
	}
	when ("flickr-albums") {
		display(filter_keys(
			qr/title|photos|count_views|count_comments/,
			flickr_select('photosets.getList', {})
		));
	}
	when ("flickr-images") {
		my $sets = {};
		my $it = filter_keys(qr/\bid|title/, flickr_select('photosets.getList', {}));
		while (my $set = $it->()) {
			my $it2 = flickr_select('photosets.getPhotos', {photoset_id => $set->{id}});
			while (my $photo = $it2->()) {
				push @{$sets->{$photo->{id}}}, $set;
			}
		}
		my $photos = flickr_select(
			'people.getPhotos',
			{user_id => 'me', sort => 'date-taken-asc', extras => 'date_taken,date_upload,tags,views'},
			);
		display(filter_keys(
			qr/title|album|datetaken\b|tags|views|sets/,
			sub {
				my $res = $photos->();
				return undef unless $res;
				$res->{sets} = $sets->{$res->{id}};
				return $res;
			}
		));
	}
	default {die "Unknown command $_"}
};

exit;

sub flickr_auth {
	my $api = shift;
	my $auth = {};
	my $authpath = catdir($ENV{HOME}, '.apickr.auth');
	if (-e $authpath) {
		$auth = LoadFile($authpath);
	}
	if (!$auth->{token}) {
		my $frob = flickr_api('auth.getFrob', api_key => $api->raw->{api_key});
		my $url = $api->raw->request_auth_url('write', $frob);
		open_browser($url);
		say "Please authorize apickr to read and write to your flickr account.";
		say "Press any key to continue.";
		local $| = 0;
		getc;
		$auth = flickr_api('auth.getToken', frob => $frob);
		DumpFile($authpath, $auth);
	}
	return $auth;
}

sub flickr_api {
	state $api = Flickr::API2->new({key => '04c25240b84f6f5d32e8e43fd4deb249', secret => 'abef06bf4946a4a2'});
	state $auth = flickr_auth($api);
	my $method = shift;
	my $params = {@_};
	$params->{auth_token} = $auth->{token} 
		if $auth;
	my $req;
	eval {
		$req = $api->execute_method('flickr.' . $method, $params);
	};
	if ($@ && (!$params->{page} || $params->{page} == 1)) {
		confess $@
	}
	if ($req && $req->{stat} eq 'ok') {
		delete $req->{stat};
		my ($first) = keys %$req;
		return simplify_flickr_response($req->{$first});
	}
	return undef;
}

sub simplify_flickr_response {
	my $r = shift;
	given (ref $r) {
		when ('HASH') {
			if (exists $r->{_content}) {
				return $r->{_content};
			} else {
				return { map {$_ => simplify_flickr_response($r->{$_})} keys %$r };
			}
		}
		when ('ARRAY') {
			return [map {simplify_flickr_response($_)} @$r];
		}
		default {
			return $r;
		}
	} 
}

sub flickr_select {
	my ($method, $args, $select) = @_;
	my ($resp, $page, $key, $i);
	$args->{per_page} = $opts->{num} ? min(500, $opts->{num} * 10) : 500;
	return sub {
		if (!$i || $i == @{$resp->{$key}}) {
			return undef if $key && @{$resp->{$key}} < 500;
			$args->{page} = ++$page;
			$resp = flickr_api($method, %$args);
			return undef unless $resp;
			$key = first {ref($resp->{$_}) eq 'ARRAY'} keys %$resp;
			$i = 0;
		}
		my $res = $resp->{$key}[$i++];
		foreach my $k (keys %$res) {
			$res->{$k} = datetime_flickr($res->{$k}) if $k =~ /date/ && $k !~ 'granularity';
		}
		return $res;
	}
}

sub aperture_select {
	my ($select, $add) = @_;
	$add = "" unless $add;
	my $dbpath = catdir($path, 'Database', 'Library.apdb');
	my $dbh = DBI->connect("dbi:SQLite:dbname=$dbpath","", "", { RaiseError => 1, AutoCommit => 0, ReadOnly => 1});
	my $sth = $dbh->prepare(
		"Select $select FROM RKVersion"
		. " JOIN RKFolder ON RKFolder.uuid = RKVersion.projectUuid"
		. " JOIN RKMaster ON RKVersion.masterUuid = RKMaster.uuid"
		. " WHERE RKVersion.isInTrash = 0 AND RKVersion.versionNumber > 0 AND RKFolder.folderType = 2 $add"
		);
	$sth->execute();
	return sub {
		my $row = $sth->fetchrow_hashref;
		if ($row && $row->{imagePath}) {
			my ($d,$dir,$name) = splitpath($row->{imagePath});
			my $prev = catdir($path, 'Previews', $dir, $row->{uuid}, $row->{name} . ".jpg");
			$row->{path} = -e $prev ? $prev : catdir($path, 'Masters', $row->{imagePath});
		}
		if ($row && $row->{imageDate}) {
			$row->{imageDate} = datetime_aperture($row->{imageDate});
		}
		$dbh->disconnect unless $row;
		return $row;
	}
}

sub datetime_aperture {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	state $macepoch  = DateTime::Format::Epoch->new(
		epoch => DateTime->new(year => 2001, month => 1, day => 1),
		);
	my ($val) = @_;
	my $res = $macepoch->parse_datetime(shift) or die "Could not parse aperture date $val";
	$res->set_formatter($formatter);
	return $res;
}

sub datetime_flickr {
	state $formatter = DateTime::Format::Strptime->new(pattern => '%Y-%m-%d %H:%M:%S');
	my ($val) = @_;
	my $res;
	if ($val =~ /^\d+$/) {
		$res = DateTime->from_epoch(epoch => $val);
	} else {
		($res = $formatter->parse_datetime($val)) or die "Could not parse flickr date $val";
	}
	$res->set_formatter($formatter);
	return $res;
}

sub filter_keys {
	my ($select, $gen) = @_;
	return sub {
		my $row = $gen->();
		return $row ? {map {$_ ~~ $select ? ($_ => $row->{$_}) : ()} keys %$row} : undef;
	}
}

sub display {
	state $num = 0;
	my ($gen) = @_;
	my ($row, $n);
	say d($row) while ($row = $gen->()) && (!$opts->{num} || $n++ < $opts->{num});
}

sub d {
	my ($row) = @_;
	return Dump(encode_rec($row));
}

sub encode_rec {
	my ($in) = @_;
	given (ref $in) {
		when ('HASH')  { return {map {$_ => encode_rec($in->{$_})} keys %$in} };
		when ('ARRAY') { return [map {encode_rec($_)} @$in] };
		default        { return $in ? encode_utf8($in) : $in }
	}
}

